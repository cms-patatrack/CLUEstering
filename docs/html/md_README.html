<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CLUEstering: CLUEstering</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CLUEstering
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">CLUEstering</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a>The CLUE algorithm is a clustering algorithm written at CERN.</p>
<p>The original algorithm was designed to work in 2 dimensions, with the data distributed in parallel layers. Unlike other clustering algorithms, CLUE takes the coordinates of the points and also their weight, which represents their energy, and calculates the energy density of each point. This energy density is used to find the seeds for each cluster, their followers and the outliers, which are dismissed as noise. CLUE takes 4 parameters in input:</p><ul>
<li><code>dc_</code>, which is the side of the box inside of which the density of a point is calculated;</li>
<li><code>rhoc</code>, which is the minimum energy density that a point must have to not be considered an outlier,</li>
<li><code>outlierDeltaFactor</code>, that multiplied by dc_ gives dm_, the side of the box inside of which the followers of a point are searched;</li>
<li><code>pointsPerBin</code>, which is the average number of points that are to be found inside a bin. This value allows to control the size of the bins.</li>
</ul>
<p>This library generalizes the original algorithm, making it N-dimensional, and turns it into a general purpose algorithm, usable by any user and applicaple to a wider range of applications, in particular outside particle physics.</p>
<p align="center"></p>
<p><img src="./images/plot2d.png" alt="" width="300" height="300" class="inline"/> <img src="./images/plot3d.png" alt="" width="300" height="300" class="inline"/> </p>
<p>The C++ code is binded using PyBind11, and the module is created locally during the installation of the library.</p>
<p>In the library is defined the <code>clusterer</code> class, which contains the methods for reading the data, running the algorithm, plotting the data both in input and output, and others. <br  />
 Outside of the class is also defined the function test_blobs, which takes the number of points and the number of dimensions, and is a way to test quickly the library, producing some N-dimensional blobs.</p>
<p align="center">Below is shown a basic example of how the library can be used: </p><div class="fragment"><div class="line">import CLUEstering as clue</div>
<div class="line"> </div>
<div class="line">clust = clue.clusterer(1., 5., 1.5)</div>
<div class="line">clust.read_data(clue.test_blobs(1000,2))</div>
<div class="line">clust.run_clue()</div>
<div class="line">clust.cluster_plotter()</div>
</div><!-- fragment --> <p><img src="./images/blobwithnoise.png" alt="" width="400" height="400" class="inline"/> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
The &lt;tt&gt;clusterer&lt;/tt&gt; class</h1>
<p>The <code>clusterer</code> class represents a wrapper class around the method <code>mainRun</code>, which is binded from <code>C++</code> and that is the method that runs the CLUE algorithm. <br  />
 When an instance of this class is created, it requires at least three parameters: <code>dc</code>, <code>rhoc</code> and <code>outlierDeltaFactor</code>. There is a fourth parameter, <code>pPBin</code>, which represents the desired average number of points found in each of the bins that the clustering space is divided into. This parameter has a default value of <code>10</code>. <br  />
 The parameters <code>dc</code>, <code>rhoc</code> and <code>outlierDeltaFactor</code> must be <code>floats</code> or a type convertible to a <code>float</code>. <code>ppBin</code>, on the other hand, is an <code>integer</code>.</p>
<p>The class has several methods:</p><ul>
<li><code>read_data</code>, which takes the data in input and inizializes the class members. The data can be in the form of list, numpy array, dictionary, string containing the path to a csv file or pandas DataFrame;</li>
<li><code>change_coordinates</code>, which allows to change the coordinate system used for clustering;</li>
<li><code>change_domains</code>, which allows to change the domain ranges of any eventual periodic coordinates;</li>
<li><code>choose_kernel</code>, which allows to change the convolution kernel used when calculating the local density of each point. The default kernel is a flat kernel with parameter <code>0.5</code>, but it can be changed to an exponential or gaussian kernel, or a custom kernel, which is user defined and can be any continuous function;</li>
<li><code>run_clue</code>, which takes no parameters and runs the CLUE algorithm;</li>
<li><code>input_plotter</code>, which plots all the points in input. This method is useful for getting an idea of the shape of the dataset before clustering. In addition to some plot customizations (like the colour or the size of the points, the addition of a grid, the axis labels and so on) it's also possible to pass the functions for the change of coordinates and change the coordinate system used for plotting.</li>
<li><code>cluster_plotter</code>, which plots the data using a different colour for each cluster. The seeds are indicated by stars and the outliers by small grey crosses.</li>
<li><code>to_csv</code>, which takes two strings, the first containing the path to a folder and the second containing the desired name for the csv file (also with the .csv suffix) and produces the csv file containing the cluster informations.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Reading data</h1>
<p>Data is read with the <code>read_data</code> method. <br  />
 For the data to be acceptable, it must contain the values of at least one coordinate for all the points, and their <code>weights</code>. The <code>weights</code> of the points represent their relative importance in the dataset, so in most cases they can all be set to 1. There are several accepted formats for providing the data: <br  />
</p><ul>
<li><code>string</code>, where the string contains the relative path to a <code>csv</code> file. The file must contain at least one column for the coordinates, which must be named as <code>x*</code> (<code>x0</code>, <code>x1</code>, ecc.) and one column for the <code>weight</code></li>
<li><code>pandas.DataFrame</code>, where the columns for the coordinates must be named <code>x*</code> (<code>x1</code>, <code>x2</code>, ecc.) and one column should contain the <code>weight</code></li>
<li><code>list</code> or <code>np.ndarray</code>, where the coordinate data should be provided as a list of lists (or array of arrays), and the weights inserted in a second, separate list/array</li>
<li><code>dictionary</code>, where the coordinate data must be contained in lists, each with key <code>x*</code> (<code>,</code>, ecc.) and the weights in another list with key <code>weight</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Generating a test dataset with &lt;tt&gt;test_blobs&lt;/tt&gt;</h1>
<p>If a user wants to test the library without using real data, they can easily do so using the <code>test_blobs</code> method. <code>test_blobs</code> generates a dataset containing any number of gaussian blobs (4 by default), i.e. regular distributions of points distributed gaussianly in a round shape. These blobs can be generated in 2 or 3 dimensions. <br  />
 It is possible to customize:</p><ul>
<li>the number of points in the dataset, through the parameter <code>n_samples</code></li>
<li>how spread out the points are, through the <code>mean</code> and <code>sigma</code> parameters</li>
<li>the spatial span over which these blobs are placed, throught the parameters <code>x_max</code> and <code>y_max</code>. By modifying this parameters it's possible to make the blobs more crammed or more well separated, thus making it harder or easier to clusterize them</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Change of kernels for the calculation of local density</h1>
<p>Since <code>version 1.3.0</code> it is possible to choose what kernel to use when calculating the local density of each point. The default choices are <code>gaussian</code>, <code>exponential</code> and <code>flat</code>. Each of the kernels require a list of parameters:</p><ul>
<li><code>flat</code>, takes a single parameter</li>
<li><code>exp</code>, takes two parameters, the amplitude and the mean.</li>
<li><code>gaus</code>, takes three parameters, the amplitude, the mean and the standard deviation. <br  />
</li>
</ul>
<p>The default kernel is a flat kernel with parameter <code>0.5</code>. The different kernels can be chosen using the <code>choose_kernel</code> method. It is also possible to use a user-defined kernel, by passing it as a function object. Custom kernels require an empty list to be passed as parameters. <br  />
 The functions used to define a custom kernel should take three parameters:</p><ul>
<li>The distance <code>dist_ij</code> between the two points.</li>
<li>The id <code>point_id</code> of the fixed point.</li>
<li>The id <code>j</code> of the neighbouring points.</li>
</ul>
<div class="fragment"><div class="line">import CLUEstering as clue</div>
<div class="line"> </div>
<div class="line">clust = clue.clusterer(1., 5., 1.5) # the default kernel is flat(0.5)</div>
<div class="line"> </div>
<div class="line"># Change to an exponential kernel </div>
<div class="line">clust.choose_kernel(&#39;exp&#39;, [1. 1.5])</div>
<div class="line"> </div>
<div class="line"># Now use a custom kernel, a linear function</div>
<div class="line">clust.choose_kernel(&#39;custom&#39;, [], lambda x, y, z: 2 * x)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
Use of periodic coordinates and change of the coordinate system</h1>
<p>Since version <code>version 1.4.0</code> it is possible to use periodic coordinates. The finite domain of a periodic variable con be specified in the call of the <code>read_data</code> method by passing a tuple containing the extremes of the domain with a keyword that specifies which coordinate should be bounded (<code>x0</code>, <code>x1</code>, <code>x2</code>, ecc.).</p>
<div class="fragment"><div class="line">import CLUEstering as clue</div>
<div class="line">from math import pi</div>
<div class="line"> </div>
<div class="line">clust = clue.clusterer(1., 5., 1.5)</div>
<div class="line">clue.read_data(&#39;my_data.csv&#39;, x1=(0, 2*pi))</div>
</div><!-- fragment --><p>The domain of a periodic variable can also be changed after the call to <code>read_data</code>, using the method <code>change_domains</code>.</p>
<p>It is also possible to change the coordinate system used for the clustering. This can be done through the <code>change_coordinates</code> method, which takes as arguments function objects representing the change of system for each of the coordinates.</p>
<div class="fragment"><div class="line">import CLUEstering as clue</div>
<div class="line">from math import pi</div>
<div class="line"> </div>
<div class="line">clust = clue.clusterer(1., 5., 1.5)</div>
<div class="line">clust.read_data(&#39;my_data.csv&#39;)</div>
<div class="line"> </div>
<div class="line"># Move from cartesian to polar coordinate system</div>
<div class="line">## x0 is the radius, x1 is the polar angle</div>
<div class="line">clust.change_coordinates(x0=lambda x, y: np.sqrt(x**2 + y**2), x1= lambda x, y: np.arctan2(y, x))</div>
</div><!-- fragment --><p>Finally, it's also possible to change the coordiantes system used for plotting. This can be useful when a specific coordinate system is well suited for clustering a given dataset, because it takes advantage of some symmetries in the data, but the plots should still be in cartesian coordinates. To do this the equations for the change of coordinates can be passed as function objects to the two plotting methods.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Input and cluster &lt;tt&gt;plotter&lt;/tt&gt; methods</h1>
<p>The <code>input_plotter</code> and <code>cluster_plotter</code> methods two plotting methods based on matplotlib. <code>input_plotter</code> is intenteded to be used as a way to observe the data before clustering and getting an idea of the expected result, whereas <code>cluster_plotter</code> plots the results of the clustering, plotting the points corresponding to the same cluster with the same colour and the outliers as small grey crosses. <br  />
 Both methods allow for a wide range of customizations:</p><ul>
<li>the title of the plot and its size can be changed with the <code>plot_title</code> and <code>title_size</code> parameters</li>
<li>the labels of the axis can be changed with the <code>x_label</code>, <code>y_label</code> and <code>z_label</code> parameters</li>
<li>the size and colour of the points. In the cluster plotter it is possible to change the size of the three classes of points (normal, seed and outlier) singularly</li>
<li>it's possible to add a grid to the point with the <code>grid</code> boolean parameter, and change its style and size with the <code>grid_style</code> and <code>grid_size</code> parameters</li>
<li>the ticks on the axis can be changed with the <code>x_ticks</code>, <code>y_ticks</code> and <code>z_ticks</code> parameters</li>
</ul>
<p>Since <code>version 1.4.0</code> both plotting methods can take function objects as kwargs, where the functions represent equations for the change of coordinates, thus allowing to change the coordinate system used for plotting.</p>
<div class="fragment"><div class="line">import CLUEstering as clue</div>
<div class="line"> </div>
<div class="line">clust = clue.clusterer(1., 5., 1.5)</div>
<div class="line">clust.read_data(data)</div>
<div class="line"> </div>
<div class="line"># Plot the data in polar coordinates</div>
<div class="line">clust.input_plotter(x0=lambda x: np.sqrt(x[0]**2 + x[1]**2),</div>
<div class="line">                    x1=lambda x: np.arctan2(x[1], x[0]))</div>
<div class="line">clust.run_clue()</div>
</div><!-- fragment --><p> This is particularly useful when the data has some kind of simmetry, which allows it to be clustered more easily in another coordinate system.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Writing the results of the clustering to file</h1>
<p>The results of the clustering can be saved to a csv file for later analysis, using the method <code>to_csv</code>. <br  />
 This method taks as parameter the path to the <code>output_folder</code> and the <code>file_name</code>, where the name of the file must include the <code>.csv</code> suffix. <br  />
 The data saved on the file include the entire input, so the points' coordinates and weights, as well as their <code>cluster_id</code>s, an integer that indicates to what cluster they belong, and <code>is_seed</code>, a boolean value indicating whether a point is a seed or not. </p><div class="fragment"><div class="line">import CLUEstering as clue</div>
<div class="line"> </div>
<div class="line">clust = clue.clusterer(1., 5., 1.5)</div>
<div class="line">clust.read_data(data)</div>
<div class="line">clust.run_clue()</div>
<div class="line">clust.to_csv(&#39;./output/&#39;, &#39;data_results.csv&#39;)</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
