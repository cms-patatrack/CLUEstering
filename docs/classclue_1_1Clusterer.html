<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CLUEstering: clue::Clusterer&lt; Ndim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CLUEstering
   </div>
   <div id="projectbrief">High-performance density-based weighted clustering library developed at CERN</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classclue_1_1Clusterer.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classclue_1_1Clusterer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">clue::Clusterer&lt; Ndim &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classclue_1_1Clusterer.html" title="The Clusterer class is the interface for running the clustering algorithm. It provides methods to set...">Clusterer</a> class is the interface for running the clustering algorithm. It provides methods to set up the clustering parameters, initializes the internal buffers and runs the clustering algorithm on host or device points.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Clusterer_8hpp_source.html">Clusterer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a891885d3d5072bc97095dfc6b21a8e84" id="r_a891885d3d5072bc97095dfc6b21a8e84"><td class="memItemLeft" align="right" valign="top"><a id="a891885d3d5072bc97095dfc6b21a8e84" name="a891885d3d5072bc97095dfc6b21a8e84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Clusterer</b> (<a class="el" href="classclue_1_1DistanceParameter.html">DistanceParameter</a>&lt; Ndim &gt; dc, float rhoc, <a class="el" href="classclue_1_1DistanceParameter.html">DistanceParameter</a>&lt; Ndim &gt; dm, <a class="el" href="classclue_1_1DistanceParameter.html">DistanceParameter</a>&lt; Ndim &gt; seed_dc=-1.f, int pPBin=128)</td></tr>
<tr class="separator:a891885d3d5072bc97095dfc6b21a8e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82d0d89207650951fc4ebde65326bf0" id="r_ac82d0d89207650951fc4ebde65326bf0"><td class="memItemLeft" align="right" valign="top"><a id="ac82d0d89207650951fc4ebde65326bf0" name="ac82d0d89207650951fc4ebde65326bf0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Clusterer</b> (Queue &amp;queue, <a class="el" href="classclue_1_1DistanceParameter.html">DistanceParameter</a>&lt; Ndim &gt; dc, float rhoc, <a class="el" href="classclue_1_1DistanceParameter.html">DistanceParameter</a>&lt; Ndim &gt; dm, <a class="el" href="classclue_1_1DistanceParameter.html">DistanceParameter</a>&lt; Ndim &gt; seed_dc=-1.f, int pPBin=128)</td></tr>
<tr class="separator:ac82d0d89207650951fc4ebde65326bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919f423bbe4eae68cf12522c7cdd290a" id="r_a919f423bbe4eae68cf12522c7cdd290a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a919f423bbe4eae68cf12522c7cdd290a">setParameters</a> (float dc, float rhoc, float dm, float seed_dc=-1.f, int pPBin=128)</td></tr>
<tr class="memdesc:a919f423bbe4eae68cf12522c7cdd290a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constuct a <a class="el" href="classclue_1_1Clusterer.html" title="The Clusterer class is the interface for running the clustering algorithm. It provides methods to set...">Clusterer</a> object.  <br /></td></tr>
<tr class="separator:a919f423bbe4eae68cf12522c7cdd290a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a3b47fa7533b3c259c515862d72145" id="r_ac7a3b47fa7533b3c259c515862d72145"><td class="memTemplParams" colspan="2">template&lt;concepts::convolutional_kernel Kernel = FlatKernel&gt; </td></tr>
<tr class="memitem:ac7a3b47fa7533b3c259c515862d72145"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac7a3b47fa7533b3c259c515862d72145">make_clusters</a> (Queue &amp;queue, <a class="el" href="classclue_1_1PointsHost.html">PointsHost</a> &amp;h_points, const Kernel &amp;kernel=<a class="el" href="classclue_1_1FlatKernel.html">FlatKernel</a>{.5f}, std::size_t block_size=256)</td></tr>
<tr class="memdesc:ac7a3b47fa7533b3c259c515862d72145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the clusters from host points.  <br /></td></tr>
<tr class="separator:ac7a3b47fa7533b3c259c515862d72145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6f436675dab613b58c7de3a84adb18" id="r_add6f436675dab613b58c7de3a84adb18"><td class="memTemplParams" colspan="2">template&lt;concepts::convolutional_kernel Kernel = FlatKernel&gt; </td></tr>
<tr class="memitem:add6f436675dab613b58c7de3a84adb18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add6f436675dab613b58c7de3a84adb18">make_clusters</a> (<a class="el" href="classclue_1_1PointsHost.html">PointsHost</a> &amp;h_points, const Kernel &amp;kernel=<a class="el" href="classclue_1_1FlatKernel.html">FlatKernel</a>{.5f}, std::size_t block_size=256)</td></tr>
<tr class="memdesc:add6f436675dab613b58c7de3a84adb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the clusters from host points.  <br /></td></tr>
<tr class="separator:add6f436675dab613b58c7de3a84adb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb0e6f19b2e26c0eff398dc101a097c" id="r_abeb0e6f19b2e26c0eff398dc101a097c"><td class="memTemplParams" colspan="2">template&lt;concepts::convolutional_kernel Kernel = FlatKernel&gt; </td></tr>
<tr class="memitem:abeb0e6f19b2e26c0eff398dc101a097c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abeb0e6f19b2e26c0eff398dc101a097c">make_clusters</a> (Queue &amp;queue, <a class="el" href="classclue_1_1PointsHost.html">PointsHost</a> &amp;h_points, <a class="el" href="classclue_1_1PointsDevice.html">PointsDevice</a> &amp;dev_points, const Kernel &amp;kernel=<a class="el" href="classclue_1_1FlatKernel.html">FlatKernel</a>{.5f}, std::size_t block_size=256)</td></tr>
<tr class="memdesc:abeb0e6f19b2e26c0eff398dc101a097c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the clusters from host and device points.  <br /></td></tr>
<tr class="separator:abeb0e6f19b2e26c0eff398dc101a097c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6079d31725596f3db4d1fd6692093974" id="r_a6079d31725596f3db4d1fd6692093974"><td class="memTemplParams" colspan="2">template&lt;concepts::convolutional_kernel Kernel = FlatKernel&gt; </td></tr>
<tr class="memitem:a6079d31725596f3db4d1fd6692093974"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6079d31725596f3db4d1fd6692093974">make_clusters</a> (<a class="el" href="classclue_1_1PointsHost.html">PointsHost</a> &amp;h_points, <a class="el" href="classclue_1_1PointsDevice.html">PointsDevice</a> &amp;dev_points, const Kernel &amp;kernel=<a class="el" href="classclue_1_1FlatKernel.html">FlatKernel</a>{.5f}, std::size_t block_size=256)</td></tr>
<tr class="memdesc:a6079d31725596f3db4d1fd6692093974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the clusters from host and device points.  <br /></td></tr>
<tr class="separator:a6079d31725596f3db4d1fd6692093974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8087258194086e679486cc9efecd10ec" id="r_a8087258194086e679486cc9efecd10ec"><td class="memTemplParams" colspan="2">template&lt;concepts::convolutional_kernel Kernel = FlatKernel&gt; </td></tr>
<tr class="memitem:a8087258194086e679486cc9efecd10ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8087258194086e679486cc9efecd10ec">make_clusters</a> (Queue &amp;queue, <a class="el" href="classclue_1_1PointsDevice.html">PointsDevice</a> &amp;dev_points, const Kernel &amp;kernel=<a class="el" href="classclue_1_1FlatKernel.html">FlatKernel</a>{.5f}, std::size_t block_size=256)</td></tr>
<tr class="memdesc:a8087258194086e679486cc9efecd10ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the clusters from device points.  <br /></td></tr>
<tr class="separator:a8087258194086e679486cc9efecd10ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac426421ce0989c84c10efc2951e984fc" id="r_ac426421ce0989c84c10efc2951e984fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac426421ce0989c84c10efc2951e984fc">setWrappedCoordinates</a> (const std::array&lt; uint8_t, Ndim &gt; &amp;wrappedCoordinates)</td></tr>
<tr class="memdesc:ac426421ce0989c84c10efc2951e984fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which coordinates are periodic.  <br /></td></tr>
<tr class="separator:ac426421ce0989c84c10efc2951e984fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946a7a452368fe84beba41b2015c1a88" id="r_a946a7a452368fe84beba41b2015c1a88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a946a7a452368fe84beba41b2015c1a88">setWrappedCoordinates</a> (std::array&lt; uint8_t, Ndim &gt; &amp;&amp;wrappedCoordinates)</td></tr>
<tr class="memdesc:a946a7a452368fe84beba41b2015c1a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which coordinates are periodic.  <br /></td></tr>
<tr class="separator:a946a7a452368fe84beba41b2015c1a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293f55603b867097d82f1de0a523d99c" id="r_a293f55603b867097d82f1de0a523d99c"><td class="memTemplParams" colspan="2">template&lt;typename... TArgs&gt; </td></tr>
<tr class="memitem:a293f55603b867097d82f1de0a523d99c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a293f55603b867097d82f1de0a523d99c">setWrappedCoordinates</a> (TArgs... wrappedCoordinates)</td></tr>
<tr class="memdesc:a293f55603b867097d82f1de0a523d99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which coordinates are periodic.  <br /></td></tr>
<tr class="separator:a293f55603b867097d82f1de0a523d99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22d1d3ed86ea9101ead4d16525db90a" id="r_ab22d1d3ed86ea9101ead4d16525db90a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclue_1_1AssociationMap.html">host_associator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab22d1d3ed86ea9101ead4d16525db90a">getClusters</a> (const <a class="el" href="classclue_1_1PointsHost.html">PointsHost</a> &amp;h_points)</td></tr>
<tr class="memdesc:ab22d1d3ed86ea9101ead4d16525db90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clusters from the host points.  <br /></td></tr>
<tr class="separator:ab22d1d3ed86ea9101ead4d16525db90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbf5214e654738b06034b3bed4ac04a" id="r_a4dbf5214e654738b06034b3bed4ac04a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclue_1_1AssociationMap.html">AssociationMap</a>&lt; Device &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dbf5214e654738b06034b3bed4ac04a">getClusters</a> (Queue &amp;queue, const <a class="el" href="classclue_1_1PointsDevice.html">PointsDevice</a> &amp;d_points)</td></tr>
<tr class="memdesc:a4dbf5214e654738b06034b3bed4ac04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clusters from the device points This function returns an associator object mapping the clusters to the points they contain.  <br /></td></tr>
<tr class="separator:a4dbf5214e654738b06034b3bed4ac04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;std::size_t Ndim&gt;<br />
class clue::Clusterer&lt; Ndim &gt;</div><p>The <a class="el" href="classclue_1_1Clusterer.html" title="The Clusterer class is the interface for running the clustering algorithm. It provides methods to set...">Clusterer</a> class is the interface for running the clustering algorithm. It provides methods to set up the clustering parameters, initializes the internal buffers and runs the clustering algorithm on host or device points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ndim</td><td>The number of dimensions of the points to cluster </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab22d1d3ed86ea9101ead4d16525db90a" name="ab22d1d3ed86ea9101ead4d16525db90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22d1d3ed86ea9101ead4d16525db90a">&#9670;&#160;</a></span>getClusters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclue_1_1AssociationMap.html">host_associator</a> <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::getClusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclue_1_1PointsHost.html">PointsHost</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>h_points</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the clusters from the host points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_points</td><td>Host points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An associator mapping clusters and points </dd></dl>

</div>
</div>
<a id="a4dbf5214e654738b06034b3bed4ac04a" name="a4dbf5214e654738b06034b3bed4ac04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbf5214e654738b06034b3bed4ac04a">&#9670;&#160;</a></span>getClusters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclue_1_1AssociationMap.html">AssociationMap</a>&lt; Device &gt; <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::getClusters </td>
          <td>(</td>
          <td class="paramtype">Queue &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclue_1_1PointsDevice.html">PointsDevice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d_points</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the clusters from the device points This function returns an associator object mapping the clusters to the points they contain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_points</td><td>Device points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An associator mapping clusters and points </dd></dl>

</div>
</div>
<a id="add6f436675dab613b58c7de3a84adb18" name="add6f436675dab613b58c7de3a84adb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6f436675dab613b58c7de3a84adb18">&#9670;&#160;</a></span>make_clusters() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
<div class="memtemplate">
template&lt;concepts::convolutional_kernel Kernel = FlatKernel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::make_clusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclue_1_1PointsHost.html">PointsHost</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>h_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kernel &amp;</td>          <td class="paramname"><span class="paramname"><em>kernel</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classclue_1_1FlatKernel.html">FlatKernel</a>{.5f}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the clusters from host points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_points</td><td>Host points to cluster </td></tr>
    <tr><td class="paramname">kernel</td><td>The convolutional kernel to use for computing the local densities, default is <a class="el" href="classclue_1_1FlatKernel.html" title="The FlatKernel class implements a flat kernel for convolution. It returns a constant value for the ke...">FlatKernel</a> with height 0.5 </td></tr>
    <tr><td class="paramname">block_size</td><td>The size of the blocks to use for clustering, default is 256 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method creates a temporary queue for the operations on the device </dd></dl>

</div>
</div>
<a id="a6079d31725596f3db4d1fd6692093974" name="a6079d31725596f3db4d1fd6692093974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6079d31725596f3db4d1fd6692093974">&#9670;&#160;</a></span>make_clusters() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
<div class="memtemplate">
template&lt;concepts::convolutional_kernel Kernel = FlatKernel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::make_clusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclue_1_1PointsHost.html">PointsHost</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>h_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclue_1_1PointsDevice.html">PointsDevice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dev_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kernel &amp;</td>          <td class="paramname"><span class="paramname"><em>kernel</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classclue_1_1FlatKernel.html">FlatKernel</a>{.5f}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the clusters from host and device points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_points</td><td>Host points to cluster </td></tr>
    <tr><td class="paramname">dev_points</td><td>Device points to cluster </td></tr>
    <tr><td class="paramname">kernel</td><td>The convolutional kernel to use for computing the local densities, default is <a class="el" href="classclue_1_1FlatKernel.html" title="The FlatKernel class implements a flat kernel for convolution. It returns a constant value for the ke...">FlatKernel</a> with height 0.5 </td></tr>
    <tr><td class="paramname">block_size</td><td>The size of the blocks to use for clustering, default is 256 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method creates a temporary queue for the operations on the device </dd></dl>

</div>
</div>
<a id="a8087258194086e679486cc9efecd10ec" name="a8087258194086e679486cc9efecd10ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8087258194086e679486cc9efecd10ec">&#9670;&#160;</a></span>make_clusters() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
<div class="memtemplate">
template&lt;concepts::convolutional_kernel Kernel = FlatKernel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::make_clusters </td>
          <td>(</td>
          <td class="paramtype">Queue &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclue_1_1PointsDevice.html">PointsDevice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dev_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kernel &amp;</td>          <td class="paramname"><span class="paramname"><em>kernel</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classclue_1_1FlatKernel.html">FlatKernel</a>{.5f}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the clusters from device points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to use for the device operations </td></tr>
    <tr><td class="paramname">dev_points</td><td>Device points to cluster </td></tr>
    <tr><td class="paramname">kernel</td><td>The convolutional kernel to use for computing the local densities, default is <a class="el" href="classclue_1_1FlatKernel.html" title="The FlatKernel class implements a flat kernel for convolution. It returns a constant value for the ke...">FlatKernel</a> with height 0.5 </td></tr>
    <tr><td class="paramname">block_size</td><td>The size of the blocks to use for clustering, default is 256 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7a3b47fa7533b3c259c515862d72145" name="ac7a3b47fa7533b3c259c515862d72145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a3b47fa7533b3c259c515862d72145">&#9670;&#160;</a></span>make_clusters() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
<div class="memtemplate">
template&lt;concepts::convolutional_kernel Kernel = FlatKernel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::make_clusters </td>
          <td>(</td>
          <td class="paramtype">Queue &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclue_1_1PointsHost.html">PointsHost</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>h_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kernel &amp;</td>          <td class="paramname"><span class="paramname"><em>kernel</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classclue_1_1FlatKernel.html">FlatKernel</a>{.5f}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the clusters from host points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to use for the device operations </td></tr>
    <tr><td class="paramname">h_points</td><td>Host points to cluster </td></tr>
    <tr><td class="paramname">kernel</td><td>The convolutional kernel to use for computing the local densities, default is <a class="el" href="classclue_1_1FlatKernel.html" title="The FlatKernel class implements a flat kernel for convolution. It returns a constant value for the ke...">FlatKernel</a> with height 0.5 </td></tr>
    <tr><td class="paramname">block_size</td><td>The size of the blocks to use for clustering, default is 256 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abeb0e6f19b2e26c0eff398dc101a097c" name="abeb0e6f19b2e26c0eff398dc101a097c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb0e6f19b2e26c0eff398dc101a097c">&#9670;&#160;</a></span>make_clusters() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
<div class="memtemplate">
template&lt;concepts::convolutional_kernel Kernel = FlatKernel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::make_clusters </td>
          <td>(</td>
          <td class="paramtype">Queue &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclue_1_1PointsHost.html">PointsHost</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>h_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclue_1_1PointsDevice.html">PointsDevice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dev_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Kernel &amp;</td>          <td class="paramname"><span class="paramname"><em>kernel</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classclue_1_1FlatKernel.html">FlatKernel</a>{.5f}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the clusters from host and device points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to use for the device operations </td></tr>
    <tr><td class="paramname">h_points</td><td>Host points to cluster </td></tr>
    <tr><td class="paramname">dev_points</td><td>Device points to cluster </td></tr>
    <tr><td class="paramname">kernel</td><td>The convolutional kernel to use for computing the local densities, default is <a class="el" href="classclue_1_1FlatKernel.html" title="The FlatKernel class implements a flat kernel for convolution. It returns a constant value for the ke...">FlatKernel</a> with height 0.5 </td></tr>
    <tr><td class="paramname">block_size</td><td>The size of the blocks to use for clustering, default is 256 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a919f423bbe4eae68cf12522c7cdd290a" name="a919f423bbe4eae68cf12522c7cdd290a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919f423bbe4eae68cf12522c7cdd290a">&#9670;&#160;</a></span>setParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::setParameters </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>dc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rhoc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>dm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>seed_dc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1.f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pPBin</em></span><span class="paramdefsep"> = </span><span class="paramdefval">128</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constuct a <a class="el" href="classclue_1_1Clusterer.html" title="The Clusterer class is the interface for running the clustering algorithm. It provides methods to set...">Clusterer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dc</td><td>Distance threshold for clustering </td></tr>
    <tr><td class="paramname">rhoc</td><td>Density threshold for clustering </td></tr>
    <tr><td class="paramname">dm</td><td>Minimum distance between clusters </td></tr>
    <tr><td class="paramname">seed_dc</td><td>Distance threshold for seed points, if -1.f, dc is used </td></tr>
    <tr><td class="paramname">pPBin</td><td>Number of points per bin, used to determine the tile size</td></tr>
  </table>
  </dd>
</dl>
<p>Constuct a <a class="el" href="classclue_1_1Clusterer.html" title="The Clusterer class is the interface for running the clustering algorithm. It provides methods to set...">Clusterer</a> object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to use for the device operations </td></tr>
    <tr><td class="paramname">dc</td><td>Distance threshold for clustering </td></tr>
    <tr><td class="paramname">rhoc</td><td>Density threshold for clustering </td></tr>
    <tr><td class="paramname">dm</td><td>Minimum distance between clusters </td></tr>
    <tr><td class="paramname">seed_dc</td><td>Distance threshold for seed points, if the default value -1.f, dc is used </td></tr>
    <tr><td class="paramname">pPBin</td><td>Number of points per bin, used to determine the tile size</td></tr>
  </table>
  </dd>
</dl>
<p>Constuct a <a class="el" href="classclue_1_1Clusterer.html" title="The Clusterer class is the interface for running the clustering algorithm. It provides methods to set...">Clusterer</a> object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to use for the device operations </td></tr>
    <tr><td class="paramname">tile_buffer</td><td>Buffer to pre-allocated tiles </td></tr>
    <tr><td class="paramname">dc</td><td>Distance threshold for clustering </td></tr>
    <tr><td class="paramname">rhoc</td><td>Density threshold for clustering </td></tr>
    <tr><td class="paramname">dm</td><td>Minimum distance between clusters </td></tr>
    <tr><td class="paramname">seed_dc</td><td>Distance threshold for seed points, if the default value -1.f, dc is used </td></tr>
    <tr><td class="paramname">pPBin</td><td>Number of points per bin, used to determine the tile size</td></tr>
  </table>
  </dd>
</dl>
<p>Set the parameters for the clustering algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dc</td><td>Distance threshold for clustering </td></tr>
    <tr><td class="paramname">rhoc</td><td>Density threshold for clustering </td></tr>
    <tr><td class="paramname">dm</td><td>Minimum distance between clusters </td></tr>
    <tr><td class="paramname">seed_dc</td><td>Distance threshold for seed points, if the defualt value -1.f, dc is used </td></tr>
    <tr><td class="paramname">pPBin</td><td>Number of points per bin, used to determine the tile size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac426421ce0989c84c10efc2951e984fc" name="ac426421ce0989c84c10efc2951e984fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac426421ce0989c84c10efc2951e984fc">&#9670;&#160;</a></span>setWrappedCoordinates() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::setWrappedCoordinates </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; uint8_t, Ndim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>wrappedCoordinates</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify which coordinates are periodic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappedCoordinates</td><td>Array of wrapped coordinates, where 1 means periodic and 0 means non-periodic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a946a7a452368fe84beba41b2015c1a88" name="a946a7a452368fe84beba41b2015c1a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946a7a452368fe84beba41b2015c1a88">&#9670;&#160;</a></span>setWrappedCoordinates() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::setWrappedCoordinates </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; uint8_t, Ndim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>wrappedCoordinates</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify which coordinates are periodic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappedCoordinates</td><td>Array of wrapped coordinates, where 1 means periodic and 0 means non-periodic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a293f55603b867097d82f1de0a523d99c" name="a293f55603b867097d82f1de0a523d99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293f55603b867097d82f1de0a523d99c">&#9670;&#160;</a></span>setWrappedCoordinates() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Ndim&gt; </div>
<div class="memtemplate">
template&lt;typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classclue_1_1Clusterer.html">clue::Clusterer</a>&lt; Ndim &gt;::setWrappedCoordinates </td>
          <td>(</td>
          <td class="paramtype">TArgs...</td>          <td class="paramname"><span class="paramname"><em>wrappedCoordinates</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify which coordinates are periodic. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TArgs</td><td>Types of the wrapped coordinates, should be convertible to uint8_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrappedCoordinates</td><td>Wrapped coordinates, where 1 means periodic and 0 means non-periodic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/CLUEstering/core/<a class="el" href="Clusterer_8hpp_source.html">Clusterer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>clue</b></li><li class="navelem"><a class="el" href="classclue_1_1Clusterer.html">Clusterer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
