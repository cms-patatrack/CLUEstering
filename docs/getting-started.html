<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CLUEstering: Getting started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CLUEstering
   </div>
   <div id="projectbrief">High-performance density-based weighted clustering library developed at CERN</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('getting-started.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Getting started</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this section we see how to write minimal code that clusters data using CLUEstering. </p>
<h2><a class="anchor" id="autotoc_md8"></a>
Using the C++ interface</h2>
<p>Below is a simple C++ code snippet, which can also be found, along with the CMake file for build, in the <code>examples</code> folder of the repository:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="CLUEstering_8hpp.html">CLUEstering/CLUEstering.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="comment">// Obtain the queue, which is used for allocations and kernel launches.</span></div>
<div class="line">  <span class="keyword">auto</span> queue = <a class="code hl_function" href="get__queue_8hpp.html#a1d26fcef2af702b8eb156bc42054ee1f">clue::get_queue</a>(0u);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Allocate the points on the host and device.</span></div>
<div class="line">  <a class="code hl_class" href="classclue_1_1PointsHost.html">clue::PointsHost&lt;2&gt;</a> h_points = <a class="code hl_function" href="read__csv_8hpp.html#a8559835368e00aab58dc190045b39582">clue::read_csv&lt;2&gt;</a>(queue, <span class="stringliteral">&quot;path-to-data.csv&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classclue_1_1PointsDevice.html">clue::PointsDevice&lt;2&gt;</a> d_points(queue, h_points.<a class="code hl_function" href="classclue_1_1PointsHost.html#a777e519a4750fd15392eb6f41d8d5e9d">size</a>());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Define the parameters for the clustering and construct the clusterer.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> dc = 20.f, rhoc = 10.f, outlier = 20.f;</div>
<div class="line">  <a class="code hl_class" href="classclue_1_1Clusterer.html">clue::Clusterer&lt;2&gt;</a> algo(queue, dc, rhoc, outlier);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Launch the clustering</span></div>
<div class="line">  <span class="comment">// The results will be stored in the `clue::PointsHost` object</span></div>
<div class="line">  algo.make_clusters(queue, h_points, d_points);</div>
<div class="line">  <span class="comment">// Read the data from the host points</span></div>
<div class="line">  <span class="keyword">auto</span> clusters_indexes = h_points.<a class="code hl_function" href="classclue_1_1PointsHost.html#abba71ff3b7cf2b5b8a80211dd60fa875">clusterIndexes</a>();  <span class="comment">// Get the cluster index for each points</span></div>
<div class="line">  <span class="keyword">auto</span> seed_map =</div>
<div class="line">      h_points.isSeed();  <span class="comment">// Obtain a boolean array indicating which points are the seeds</span></div>
<div class="line">                          <span class="comment">// i.e. the cluster centers</span></div>
<div class="line">}</div>
<div class="ttc" id="aCLUEstering_8hpp_html"><div class="ttname"><a href="CLUEstering_8hpp.html">CLUEstering.hpp</a></div><div class="ttdoc">Header file for the CLUEstering library.</div></div>
<div class="ttc" id="aclassclue_1_1Clusterer_html"><div class="ttname"><a href="classclue_1_1Clusterer.html">clue::Clusterer</a></div><div class="ttdoc">The Clusterer class is the interface for running the clustering algorithm. It provides methods to set...</div><div class="ttdef"><b>Definition</b> Clusterer.hpp:27</div></div>
<div class="ttc" id="aclassclue_1_1PointsDevice_html"><div class="ttname"><a href="classclue_1_1PointsDevice.html">clue::PointsDevice</a></div><div class="ttdoc">The PointsDevice class is a data structure that manages points on a device. It provides methods to al...</div><div class="ttdef"><b>Definition</b> PointsDevice.hpp:25</div></div>
<div class="ttc" id="aclassclue_1_1PointsHost_html"><div class="ttname"><a href="classclue_1_1PointsHost.html">clue::PointsHost</a></div><div class="ttdoc">The PointsHost class is a data structure that manages points in host memory. It provides methods to a...</div><div class="ttdef"><b>Definition</b> PointsHost.hpp:23</div></div>
<div class="ttc" id="aclassclue_1_1PointsHost_html_a777e519a4750fd15392eb6f41d8d5e9d"><div class="ttname"><a href="classclue_1_1PointsHost.html#a777e519a4750fd15392eb6f41d8d5e9d">clue::PointsHost::size</a></div><div class="ttdeci">ALPAKA_FN_HOST int32_t size() const</div><div class="ttdoc">Returns the number of points.</div></div>
<div class="ttc" id="aclassclue_1_1PointsHost_html_abba71ff3b7cf2b5b8a80211dd60fa875"><div class="ttname"><a href="classclue_1_1PointsHost.html#abba71ff3b7cf2b5b8a80211dd60fa875">clue::PointsHost::clusterIndexes</a></div><div class="ttdeci">ALPAKA_FN_HOST auto clusterIndexes() const</div><div class="ttdoc">Returns the cluster indexes of the points as a const span.</div></div>
<div class="ttc" id="aget__queue_8hpp_html_a1d26fcef2af702b8eb156bc42054ee1f"><div class="ttname"><a href="get__queue_8hpp.html#a1d26fcef2af702b8eb156bc42054ee1f">clue::get_queue</a></div><div class="ttdeci">clue::Queue get_queue(TIdx device_id=TIdx{})</div><div class="ttdoc">Get an alpaka queue created from a device correspoding to a given index.</div><div class="ttdef"><b>Definition</b> get_queue.hpp:20</div></div>
<div class="ttc" id="aread__csv_8hpp_html_a8559835368e00aab58dc190045b39582"><div class="ttname"><a href="read__csv_8hpp.html#a8559835368e00aab58dc190045b39582">clue::read_csv</a></div><div class="ttdeci">clue::PointsHost&lt; NDim &gt; read_csv(TQueue &amp;queue, const std::string &amp;file_path)</div><div class="ttdoc">Read points from a CSV file into a PointsHost object.</div></div>
</div><!-- fragment --><p>The first step is to create the <code>Queue</code> object. A <code>Queue</code> can be thought as a <code>std::thread</code> or as a stream of CUDA/HIP, and represents a queue of operations to be executed on a specific device. The queue will be used to allocate memory and to launch the kernels on the device. The <code><a class="el" href="get__queue_8hpp.html#a1d26fcef2af702b8eb156bc42054ee1f" title="Get an alpaka queue created from a device correspoding to a given index.">clue::get_queue</a></code> function provides a convenient way to obtain a queue from a specific device, whose index is to passed as an argument. Alternatively, the <code><a class="el" href="get__device_8hpp.html#a8aaf8c1e70914c5c931e44be18f0b505" title="Get the alpaka device corresponding to a given index.">clue::get_device</a></code> function can be used to obtain a device object, repcresenting an accelerator device, which can be then used to create a queue: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> device = <a class="code hl_function" href="get__device_8hpp.html#a8aaf8c1e70914c5c931e44be18f0b505">clue::get_device</a>(0u);          <span class="comment">// Get the device with index 0</span></div>
<div class="line"><span class="keyword">auto</span> queue = <a class="code hl_function" href="get__queue_8hpp.html#a1d26fcef2af702b8eb156bc42054ee1f">clue::get_queue</a>(device);        <span class="comment">// We then create a queue from the device with the `get_queue` function</span></div>
<div class="line"><span class="keyword">auto</span> another_queue = clue::Queue(device);    <span class="comment">// or we can also call the Queue&#39;s constructor directly</span></div>
<div class="ttc" id="aget__device_8hpp_html_a8aaf8c1e70914c5c931e44be18f0b505"><div class="ttname"><a href="get__device_8hpp.html#a8aaf8c1e70914c5c931e44be18f0b505">clue::get_device</a></div><div class="ttdeci">clue::Device get_device(uint32_t device_id)</div><div class="ttdoc">Get the alpaka device corresponding to a given index.</div><div class="ttdef"><b>Definition</b> get_device.hpp:16</div></div>
</div><!-- fragment --><p>The next step is to create the containers for the device points. CLUEstering provides the <code><a class="el" href="classclue_1_1PointsHost.html" title="The PointsHost class is a data structure that manages points in host memory. It provides methods to a...">clue::PointsHost</a></code> and <code><a class="el" href="classclue_1_1PointsDevice.html" title="The PointsDevice class is a data structure that manages points on a device. It provides methods to al...">clue::PointsDevice</a></code> containers, representing respectively data allocated on the host and on the device. Here the data is read from a CSV file using the <code><a class="el" href="read__csv_8hpp.html#a8559835368e00aab58dc190045b39582" title="Read points from a CSV file into a PointsHost object.">clue::read_csv</a></code> function, which returns a <code>PointsHost</code> object, and then an empty <code>PointsDevice</code> object is created.</p>
<p>Then, the <code><a class="el" href="classclue_1_1Clusterer.html" title="The Clusterer class is the interface for running the clustering algorithm. It provides methods to set...">clue::Clusterer</a></code>, which is the object that handles the internal allocations and contains the algorithm logic, is created. The <code>Clusterer</code> requires the CLUE algorithm's parameters to be passed. Their meaning is explained in the introduction section, along with a description of the algorithm.</p>
<p>Finally, the algorithm is launched with the <code>make_clusters</code> method, which takes as arguments the queue to use for the device operations, the host and device points and optionally the kernel to use for computing the points' density and the block-size that the kernels are launched with. The input data is copied from the host to the device container, the algorithm is then executed on the device, where the results are computed and finally copied back to the host container.</p>
<p>The results of the clustering can then be read from the host points: the <code><a class="el" href="classclue_1_1PointsHost.html#abba71ff3b7cf2b5b8a80211dd60fa875" title="Returns the cluster indexes of the points as a const span.">clue::PointsHost::clusterIndexes</a></code> method returns a span of integers representing the cluster index for each point, while the <code>clue::PointsHost::isSeed</code> method returns a boolean array indicating which points are the seeds of the clusters.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
How to compile the code</h3>
<p>In order to compile code that uses CLUEstering, three steps are needed:</p><ol type="1">
<li>including the library headers, either by fetching the source code (with <code>wget</code> git submodule, CMake <code>FetchContent</code> or similar) or by installing it getting the path with CMake <code>find_package</code> command.</li>
<li>including and if needed linking the backend specific libraries and/or compilers</li>
<li>specifying the alpaka backend to use</li>
</ol>
<p>Here is a full example of a CMake file that compiles the code above: </p><div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.16.0)</div>
<div class="line">project(CLUEsteringExample)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_CXX_STANDARD 20)</div>
<div class="line">set(CMAKE_CXX_STANDARD_REQUIRED ON)</div>
<div class="line">set(CMAKE_CXX_EXTENSIONS OFF)</div>
<div class="line"> </div>
<div class="line">find_package(CLUEstering)</div>
<div class="line">if(NOT CLUEstering_FOUND)</div>
<div class="line">  message(</div>
<div class="line">    FATAL_ERROR</div>
<div class="line">      &quot;CLUEstering not found. Please install it.&quot;</div>
<div class="line">  )</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line">if(ALPAKA_ACC_CPU_B_SEQ_T_SEQ_ENABLED)</div>
<div class="line">  add_executable(serial.out main.cpp)</div>
<div class="line">  target_compile_definitions(serial.out</div>
<div class="line">                             PRIVATE ALPAKA_ACC_CPU_B_SEQ_T_SEQ_ENABLED)</div>
<div class="line">endif()</div>
<div class="line">if(ALPAKA_ACC_CPU_B_TBB_T_SEQ_ENABLED)</div>
<div class="line">  find_package(TBB REQUIRED)</div>
<div class="line"> </div>
<div class="line">  if(NOT TARGET TBB::tbb)</div>
<div class="line">    message(FATAL_ERROR &quot;TBB not found. Please install it.&quot;)</div>
<div class="line">  endif()</div>
<div class="line">  add_executable(tbb.out main.cpp)</div>
<div class="line">  target_compile_definitions(tbb.out PRIVATE ALPAKA_ACC_CPU_B_TBB_T_SEQ_ENABLED)</div>
<div class="line">  target_link_libraries(tbb.out PRIVATE TBB::tbb)</div>
<div class="line">endif()</div>
<div class="line">if(ALPAKA_ACC_CPU_B_OMP2_T_SEQ_ENABLED)</div>
<div class="line">  find_package(OpenMP REQUIRED)</div>
<div class="line"> </div>
<div class="line">  if(NOT TARGET OpenMP::OpenMP_CXX)</div>
<div class="line">    message(FATAL_ERROR &quot;OpenMP not found. Please install it.&quot;)</div>
<div class="line">  endif()</div>
<div class="line">  add_executable(openmp.out main.cpp)</div>
<div class="line">  target_compile_definitions(openmp.out</div>
<div class="line">                             PRIVATE ALPAKA_ACC_CPU_B_OMP2_T_SEQ_ENABLED)</div>
<div class="line">  target_link_libraries(openmp.out PRIVATE OpenMP::OpenMP_CXX)</div>
<div class="line">endif()</div>
<div class="line">if(ALPAKA_ACC_GPU_CUDA_ENABLED)</div>
<div class="line">  include(CheckLanguage)</div>
<div class="line">  check_language(CUDA)</div>
<div class="line">  if(CMAKE_CUDA_COMPILER)</div>
<div class="line">    set_source_files_properties(main.cpp PROPERTIES LANGUAGE CUDA)</div>
<div class="line">    add_executable(cuda.out main.cpp)</div>
<div class="line">    target_compile_definitions(cuda.out PRIVATE ALPAKA_ACC_GPU_CUDA_ENABLED)</div>
<div class="line">    target_compile_options(cuda.out PRIVATE --expt-relaxed-constexpr)</div>
<div class="line">    set_target_properties(</div>
<div class="line">      cuda.out PROPERTIES CUDA_SEPARABLE_COMPILATION ON CUDA_ARCHITECTURES</div>
<div class="line">                                                        &quot;50;60;61;62;70;80;90&quot;)</div>
<div class="line">  else()</div>
<div class="line">    message(FATAL_ERROR &quot;CUDA not found. Please install it.&quot;)</div>
<div class="line">  endif()</div>
<div class="line">endif()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
Using the Python interface</h2>
<p>Here is a minimal example of a Python code using CLUEstering: </p><div class="fragment"><div class="line"><span class="keyword">import</span> CLUEstering <span class="keyword">as</span> clue</div>
<div class="line"> </div>
<div class="line">clust = clue.clusterer(1., 5., 1.5)</div>
<div class="line">clust.read_data(data)</div>
<div class="line">clust.run_clue()</div>
<div class="line">clust.to_csv(<span class="stringliteral">&#39;./output/&#39;</span>, <span class="stringliteral">&#39;data_results.csv&#39;</span>)</div>
</div><!-- fragment --><p> Just like in the C++ interface, the <code>CLUEstering.clusterer</code> constructor just takes the CLUE's parameters as arguments. The parameters can also be updated using the <code>CLUEstering.clusterer.set_params</code> method. The data is read using the <code>CLUEstering.clusterer.read_data</code> method, that accepts five types of data formats: pandas DataFrames, Python lists, Numpy arrays, Python dictionaries and strings containing paths to CSV files. The algorithm is run with the <code>CLUEstering.clusterer.run_clue</code> method. The backend used for running the algorithm can be specified by passing a string to <code>run_clue</code>: </p><div class="fragment"><div class="line">clust.run_clue(<span class="stringliteral">&quot;cpu serial&quot;</span>)</div>
<div class="line">clust.run_clue(<span class="stringliteral">&quot;cpu tbb&quot;</span>)</div>
<div class="line">clust.run_clue(<span class="stringliteral">&quot;cpu openmp&quot;</span>)</div>
<div class="line">clust.run_clue(<span class="stringliteral">&quot;gpu cuda&quot;</span>)</div>
<div class="line">clust.run_clue(<span class="stringliteral">&quot;gpu hip&quot;</span>)</div>
</div><!-- fragment --><p> NOTE: the support for the SYCL backends is still in an experimental state and is not included in the Python interface as of version <code>2.7.2</code>.</p>
<p>The results of the clustering can be accessed with the clsuter's public getters: </p><div class="fragment"><div class="line">clust.n_clusters             <span class="comment"># returns the number of clusters</span></div>
<div class="line">clust.n_seeds                <span class="comment"># returns the number of seeds</span></div>
<div class="line">clust.clusters               <span class="comment"># returns a list of the clusters found</span></div>
<div class="line">clust.cluster_ids            <span class="comment"># returns an array with the cluster index of each point</span></div>
<div class="line">clust.is_seed                <span class="comment"># returns an boolean array specifying which points are seeds</span></div>
<div class="line">clust.cluster_points         <span class="comment"># returns the clusters as nested arrays containing the points in each cluster</span></div>
<div class="line">clust.points_per_cluster     <span class="comment"># returns an array with the number of points in each cluster</span></div>
<div class="line">clust.output_df              <span class="comment"># returns a dataframe with the input data and the results of the clustering</span></div>
</div><!-- fragment --><p> the output dataframe can also be exported to a CSV file with the <code>CLUEstering.clusterer.to_csv</code> method.</p>
<p>Finally, the <code>clusterer</code> provides the <code>CLUEstering.clusterer.input_plotter</code> method for plotting the input data and the <code>CLUEstering.clusterer.cluster_plotter</code> method for plotting the clustered data.</p>
<div class="image">
<img src="input-plotter.png" alt="" width="500px"/>
<div class="caption">
Data plotted with the input plotter</div></div>
  <div class="image">
<img src="output-plotter.png" alt="" width="500px"/>
<div class="caption">
Data plotted with the cluster plotter</div></div>
 <h2><a class="anchor" id="autotoc_md11"></a>
Format of the data required by CLUEstering</h2>
<p>To finish this section, we describe what is the expected format for the data passed to CLUEstering. </p>
<h3><a class="anchor" id="autotoc_md12"></a>
CSV files</h3>
<p>When the data is passed from a CSV file, each row should contain the data for each point, by putting in order the coordinates and then the point's weight. Below is an example: </p><div class="fragment"><div class="line">x,y,z,weight</div>
<div class="line">-9.95,5.17,0.15,1.0</div>
<div class="line">-9.43,5.68,0.15,1.0</div>
<div class="line">-11.0,7.29,0.15,1.0</div>
<div class="line">-10.7,-4.37,0.15,1.0</div>
<div class="line">3.5,4.48,0.15,1.0</div>
<div class="line">3.0,2.94,0.15,1.0</div>
<div class="line">-9.97,4.04,0.15,1.0</div>
<div class="line">-10.36,-4.39,0.15,1.0</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md13"></a>
Passing data to <code>clue::PointsHost</code> and <code>clue::PointsDevice</code></h3>
<p>The host and device containers in the C++ interface expect data to be passed in an SoA format, meaning that the coordinate values of all the points in each dimension should be adjacent in memory. The difference between an SoA layout and a traditional AoS layout is shown in the diagram below. </p><div class="image">
<object type="image/svg+xml" data="aos_vs_soa.svg" style="pointer-events: none;"></object>
</div>
<p>  If the is already contained in external containers, these can be passed to the <code><a class="el" href="classclue_1_1PointsHost.html" title="The PointsHost class is a data structure that manages points in host memory. It provides methods to a...">clue::PointsHost</a></code> constructor either as pointers, <code>std::span</code>s or any container satisfying the <code>std::contiguous_range</code> concept. The data can be passed through either two or four buffers:</p><ul>
<li><b>two buffers</b>: the first one should contain all the coordinates and the weights, and the second one the results of the clustering, i.e. the cluster indexes and the <code>is_seed</code> map.</li>
<li><b>four buffers</b>: the first buffer should contain the coordinates, the second the weights and the last two should contain the results.</li>
</ul>
<h3><a class="anchor" id="autotoc_md14"></a>
Passing data in the Python interface</h3>
<p>As said above, the <code>CLUEstering.clusterer.read_data</code> method takes input data in five different formats:</p><ul>
<li>for Python dictionaries, pandas DataFrames and CSV files, the same naming conventions for the data members apply</li>
<li>for Python lists and Numpy arrays, the coordinates can be passed both in AoS and SoA format, where in the first case it will be automatically converted to SoA before calling the C++ module. In both formats, the weights should be passed as a separate nested array. <div class="fragment"><div class="line"><span class="comment"># The same applies to Numpy arrays</span></div>
<div class="line">data_aos = [[x0, y0, z0], [x1, y1, z1], [x2, y2, z2], [w0, w1, w2]]</div>
<div class="line">data_soa = [[[x0, x1, x2], [y0, y1, y2], [z0, z1, z2]], [w0, w1, w2]]</div>
</div><!-- fragment --> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
